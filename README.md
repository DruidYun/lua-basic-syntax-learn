Lua语法学习 B站唐老狮讲的课 以C#基础的课<!--more-->

## 环境搭建

### 环境安装

- https://github.com/rjpcomputing/luaforwindows

### IDE（集成开发环境）

- 实际项目开发使用的IDE

	- VSCode
	- IDEA
	- LuaStudio
	- 等等

- 学习使用

	- Sublime Text
	- 轻便快捷

## Lua语法

### HelloWorld

- 打印

	- print()
	- Lua可以不写;（分号）

- 注释

	- 单行注释

		- \--
		- --[[

	- 多行注释

		- --[[
多行注释1
]]
		- --[[
多行注释2
]]--
		- --[[
多行注释3
--]]

### 变量

- 四种简单变量类型

	- nil

		- nil 有点类似 C#中的null 

	- number
	- string
	- boolean

- 四种复杂变量类型(目前不讨论之后分开讨论)

	- 函数function
	- 表table
	- 数据结构userdata
	- 协同程序thread(线程)

- Lua中所有的变量声明 都不需要声明变量类型 它会自动的判断类型
- Lua中的一个变量可以随便赋值 ——自动识别类型
- 通过type()函数 参数变量名 返回值string 我们可以获得变量的类型

### 字符串

- 字符串声明可以用单引号也可以用双引号
- 字符串长度

	- 在字符串变量名前加#号
	- 英文字符占1个长度，中文字符占3个长度

- 字符串多行打印

	- 转义字符\n
	- s=[[我在
学	
Lua]]

- 字符串拼接

	- ..(就是用这两个点连接)

		- print("123".."456")
		- print(s1..s2)

	- 格式控制符

		- print(string.format("我在学Lua第%d天了",3))
		- --%d :接受一个数字并将其转化为有符号的整数格式
		- --%a :与任何字符拼接
		- --%s :接受一个字符串并按照给定的参数格式化该字符串
		- 等等格式控制符

- 字符串提供的公共方法

	- 小写转大写

		- string.upper(str)

	- 大写转小写

		- string.lower(str)

	- 翻转字符串

		- string.reverse(str)

	- 字符串索引查找

		- string.find(str,"Cde")

			- Lua支持多返回值，索引从1开始

	- 截取字符串

		- string.sub(str,3)
		- string.sub(str,3,4)

	- 字符串重复

		- string.rep(str,2)

	- 字符串修改

		- string.gsub(str,"Cd","**")

			- 返回修改后的内容，和替换了几次

		- str = "abCdegGCd"
			print(string.gsub(str,"Cd","**")
		- 这里返回 “ab\*\**egG\*\**  2”
	
- 字符转ASCII码
	
	- a=string.byte("Lua",1)
	
		- a变成了76
	
- ASCII码转字符
	
	- string.char(a)
	
		- 返回"L"

### 运算符

- 算数运算符

	- \+ \- * / % ^（最后一个是幂运算符）
	- 没有自增自减 ++ \--
	- 没有复合运算符 += -= /= *= %=
	- 字符串可以进行 算数运算符操作 会自动转成number

- 条件运算符

	- < > <= >= == ~=(最后一个是不等于符号，不是!=了

- 逻辑运算符

	- && || !  这是C#中的逻辑与 逻辑或 取反
	- and or not 这是Lua中的对应逻辑与 逻辑或 取反  
	- 也支持逻辑运算的“短路”规则

		- print(false and print("123")) \--短路 已经满足为false条件 不执行后续代码
		- print(true and print("123")) 

- 位运算符

	- 不支持  & | 不支持位运算符 需要自己实现

- 三目运算符

	- 也不支持  ? : 

### 条件分支语句

- if 条件 then ... end

- if 条件 then ... else ... end

- if 条件 then ... elseif ...then ...end

  - elseif需要连在一起

- 不支持switch，可以自己实现

### 循环语句

  - while循环

    - while 条件 do ... end

  - repeat until循环

    - repeat ... until 跳出条件(满足就结束)

  - for循环

    - for 变量名=起始值,结束值 do ... end

      - 默认递增 每次+1
      - 要自己设定每次的变化就 for 变量名=起始值,结束值,增值 do ... end

###  函数

- 两种声明方式

  - 一个在function后面取名字
  - 一个不取名字 用一个变量来存储

- 函数传参时

  - 个数传多了 或者 传少了 不会报错
  - 多了会丢弃
  - 少了会补空

- 函数返回值

  - 外部用多个变量来接取
  - 接少接多不影响
  - 少了丢弃
  - 多了为nil

- 函数的类型 function
- 不支持函数重载
- 变长参数

  - ...
  - 先用 表 接 再使用

- 函数嵌套

  - 函数里面声明函数
  - 闭包：函数改变变量生命周期

### 复杂数据类型——表

- 表是一切复杂数据的基础：数组、二组数组、字典、类等等
- 数组和二维数组——表

  - 索引是从1开始
  - 中间为nil会断掉长度获取不准确
  - 长度获取——#
  - 自定义索引

    - 计算长度时：忽略小于等于0的索引
    - 自定义索引跳跃性设置，如果只挑一格 就不会断掉，长度受自定义索引最大值影响
### 迭代器遍历

- ipairs

	- 不能找到0和0以下的自定义索引的内容
	- 如果从1开始 索引顺序断了 后面的内容也找不到

- pairs

	- 建议使用它遍历各种不规则的表
	- 它可以得到所有信息

- for i,k in pairs(表) do 
	end
	
### 复杂数据类型——表2

- 字典

  - 字典的本质也是表
  - 访问

    - 可以通过中括号访问
    - 点访问 数字不行

  - 修改

    - 直接访问赋值

  - 新增

    - 直接加key赋值

  - 删除

    - 置空

- 类

  - 成员变量的声明

    - 表内部声明
    - 表外部声明

  - 成员函数的声明

    - 表内部声明
    - 表外部的声明

      - 和函数声明的两种方式相同
      - 变量的形式
      - function+名字的形式

    - 在表内部函数想要访问表的变量或方法时必须要知道他们来自哪里
    - 点和冒号

      - 点就是正常调用函数
      - 冒号是会把调用者作为第一个参数

    - 冒号可以用来声明函数 只能是function+名字的形式 声明

      - 如果是冒号声明 相当于有一个默认参数

    - self——>就是用来冒号声明时作为第一参数的代表（self不是this！！！）

- 表的公共操作

  - 表提供的公共方法table.方法名 调用
  - 插入
  - 移除
  - 排序
  - 拼接

### 多Lua脚本执行

- 全局变量和局部变量

  - 局部变量就是前面用local修饰

- 多脚本执行

  - require('脚本名')
  - 脚本的最后可以return一个外部希望获取的内容 一般情况是一个局部变量

- 脚本卸载

  - package.loaded["脚本名"]得到一个boolean true为加载 nil就是没有加载
  - package.loaded["脚本名"] = nil 卸载

- _G

  - 是一个总表(table) 他将我们声明的所有全局变量存储在其中
  - 本地变量 加了local的变量不会存到大_G表中

### 特殊用法

- 多变量赋值

  - 如果后面的值不够 会自动补空
  - 如果后面的值多了 会自动省略

- 多返回值

  - 你用几个变量接 就有几个值
  - 如果少了 就少接几个 如果多了 就自动补空

- and or

  - 逻辑与 逻辑或
  - and or 他们不仅可以连接boolean 任何东西都可以用来连接
  - 在lua中 只有nil 和false 才认为是假
  - "短路" 他们只需要判断 第一个 是否满足 就会停止计算了
  - 可以模拟三目运算符

    - res = (x>y) and  x or y

### 协程

- 创建协同程序

  - coroutine.create(函数)

    - 返回值是一个thread对象

  - coroutine.wrap(函数)

    - 返回值是一个函数

- 启动协程

  - coroutine.resume(协程对象)

    - 默认返回值是第一个是否开启成功

  - 直接调用函数(wrap创建的)

- 协程挂起

  - coroutine.yield(返回值)

- 协程状态

  - coroutine.status(协程对象或者协程函数)

    - dead
    - suspended
    - running
    - normal

  - coroutine.yield()

    - 返回一个线程编号

### 元表

- 元表的概念

  - 任何表变量都可以作为另一表变量的原表
  - 任何表变量都可以有自己的元表
  - 当我们子表中进行一些特定操作时 会执行元表(没有子表的概率 子表只是方便理解 表示有元表的表)

- 设置元表 得到元表

  - setmetatable(子表,元表)
  - getmetatable(子表)

- 特定操作

  - __tostring

    - 都是两个下划线

  - __call
  - 运算符重载
  - __index
  - __newindex

- raw

  - rawget

    - 绕开__index

  - rawset

    - 绕开__newindex

### 面向对象

- 封装

  - 表就是表现类的一种形式
  - 实现了new方法

    - 元表
    - 本质上是创建了一个空表
    - __index

  - 修改创建出来的对象的属性变量时

    - 为了这个空表对象 新建了一个成员属性(变量）

  - 冒号

    - self代表函数调用者

- 继承

  - 写了一个继承方法
  - _G来根据字符串创建了一个新的表（类）
  - 元表和__index相关知识点 类达到了一个继承的表现

- 多态

  - 相同方法名 子类有不同的处理逻辑
  - 直接重写这个方法
  - 如果要保留父类逻辑执行

    - 加入自定义base属性
    - subClass方法中赋值

  - 大坑

    - 通过base调用父类方法时，一定记住 不要用冒号调用然后自己传第一个参数 进入父类函数内部

### 自带库

- os
- math
- package

### 垃圾回收

- 关键字collectgarbage("命令")
- 命令

  - count

    - 获取内存数 单位kb

  - collect

    - 进行一次完整的垃圾回收

  - 其他

    - 自动进行垃圾回收

## 感谢唐老狮的课
课程链接：https://www.bilibili.com/video/BV1iA411n7oQ?p=1&vd_source=bff96494067939d9663643d0d20fbc55
